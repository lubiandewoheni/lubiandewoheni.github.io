<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <a href="https://wwus.lanzouj.com/b04ex48uj">蓝奏云-集合an0q</a>
    <br>
    <a href="https://www.123pan.com/s/XIh5Vv-UmPJH.html">123-集合</a>

<div>
    <!--聊天室-->
    <a href="http://xkk.pythonanywhere.com/chat_room.html"></a>
</div>

<script>
    /*
    实验一 线性表的建立与应用
    // 建立一个有n个结点的单链表，进行查询、修改、删除和插入操作
#include <stdio.h>
#include <stdlib.h>

//定义结构体
typedef struct node {
    int data;
    struct node *next;
} Node, *LinkedList;

//初始化链表
LinkedList initList() {
    LinkedList L = (LinkedList)malloc(sizeof(Node));
    L->next = NULL;
    return L;
}

//创建链表
LinkedList createList(int n) {
    LinkedList L = initList();
    Node *p = L;
    for (int i = 0; i < n; i++) {
        Node *newNode = (Node *)malloc(sizeof(Node));
        printf("请输入第%d个结点的值：", i + 1);
        scanf("%d", &newNode->data);
        newNode->next = NULL;
        p->next = newNode;
        p = p->next;
    }
    return L;
}

//遍历链表
void traverseList(LinkedList L) {
    Node *p = L->next;
    while (p) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

//查询数据
void searchList(LinkedList L) {
    int x;
    printf("请输入要查询的数据：");
    scanf("%d", &x);
    Node *p = L->next;
    while (p) {
        if (p->data == x) {
            printf("查询成功，该数据在链表中！\n");
            return;
        }
        p = p->next;
    }
    printf("查询失败，该数据不在链表中！\n");
}

//修改单个数据
void modifyList(LinkedList L) {
    int i, x;
    printf("请输入要修改的结点位置：");
    scanf("%d", &i);
    printf("请输入新的结点值：");
    scanf("%d", &x);
    Node *p = L->next;
    for (int j = 1; j < i; j++) {
        p = p->next;
    }
    p->data = x;
    printf("修改成功！\n");
}

//删除单个数据
void deleteList(LinkedList L) {
    int x;
    printf("请输入要删除的结点值：");
    scanf("%d", &x);
    Node *p = L->next, *pre = L;
    while (p) {
        if (p->data == x) {
            pre->next = p->next;
            free(p);
            printf("删除成功！\n");
            return;
        }
        pre = p;
        p = p->next;
    }
    printf("删除失败，该结点不存在！\n");
}

//在任意位置插入操作
void insertList(LinkedList L) {
    int i, x;
    printf("请输入要插入的位置：");
    scanf("%d", &i);
    printf("请输入要插入的结点值：");
    scanf("%d", &x);
    Node *p = L->next, *pre = L;
    for (int j = 1; j < i; j++) {
        pre = p;
        p = p->next;
    }
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = x;
    newNode->next = p;
    pre->next = newNode;
    printf("插入成功！\n");
}

//主函数
int main() {
    int n;
    printf("请输入链表长度：");
    scanf("%d", &n);
    LinkedList L = createList(n);
    int choice;
    while (1) {
        printf("请选择操作：\n");
        printf("1. 遍历链表\n");
        printf("2. 查询数据\n");
        printf("3. 修改单个数据\n");
        printf("4. 删除单个数据\n");
        printf("5. 在任意位置插入操作\n");
        printf("0. 退出程序\n");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                traverseList(L);
                break;
            case 2:
                searchList(L);
                break;
            case 3:
                modifyList(L);
                break;
            case 4:
                deleteList(L);
                break;
            case 5:
                insertList(L);
                break;
            case 0:
                printf("程序已退出！\n");
                return 0;
            default:
                printf("输入有误，请重新输入！\n");
                break;
        }
    }
    return 0;
}

*/
</script>
<script>/*
实验2 二叉树的创建与遍历
//从文件读取数据建立二叉树，进行该树的先根、后根和中根递归与非递归遍历
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

struct TreeNode {
	int val; // 节点的值
	struct TreeNode* left; // 左子树
	struct TreeNode* right; // 右子树
};

void createTree(struct TreeNode** root, FILE* fin) {
	int val;
	if (fscanf(fin, "%d", &val) == 1) {
		if (val == -1) {
			*root = NULL; // 如果读到-1，说明这个节点为空
		} else {
			*root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); // 为节点分配空间
			(*root)->val = val; // 节点的值为val
			createTree(&((*root)->left), fin); // 递归创建左子树
			createTree(&((*root)->right), fin); // 递归创建右子树
		}
	}
}

void preOrderRecursive(struct TreeNode* root) {
	if (root) {
		printf("%d ", root->val); // 先访问根节点
		preOrderRecursive(root->left); // 再访问左子树
		preOrderRecursive(root->right); // 最后访问右子树
	}
}

void inOrderRecursive(struct TreeNode* root) {
	if (root) {
		inOrderRecursive(root->left); // 先访问左子树
		printf("%d ", root->val); // 再访问根节点
		inOrderRecursive(root->right); // 最后访问右子树
	}
}

void postOrderRecursive(struct TreeNode* root) {
	if (root) {
		postOrderRecursive(root->left); // 先访问左子树
		postOrderRecursive(root->right); // 再访问右子树
		printf("%d ", root->val); // 最后访问根节点
	}
}

void preOrderNonRecursive(struct TreeNode* root) {
	struct TreeNode* stack[100];
	int top = -1;
	while (root || top != -1) {
		while (root) {
			printf("%d ", root->val); // 访问根节点
			stack[++top] = root;
			root = root->left; // 访问左子树
		}
		if (top != -1) {
			root = stack[top--];
			root = root->right; // 访问右子树
		}
	}
}

void inOrderNonRecursive(struct TreeNode* root) {
	struct TreeNode* stack[100];
	int top = -1;
	while (root || top != -1) {
		while (root) {
			stack[++top] = root;
			root = root->left; // 访问左子树
		}
		if (top != -1) {
			root = stack[top--];
			printf("%d ", root->val); // 访问根节点
			root = root->right; // 访问右子树
		}
	}
}

void postOrderNonRecursive(struct TreeNode* root) {
	struct TreeNode* stack[100];
	int top = -1;
	struct TreeNode* lastVisited = NULL;
	while (root || top != -1) {
		while (root) {
			stack[++top] = root;
			root = root->left; // 访问左子树
		}
		root = stack[top];
		if (!root->right || root->right == lastVisited) {
			printf("%d ", root->val); // 访问根节点
			top--;
			lastVisited = root;
			root = NULL;
		} else {
			root = root->right; // 访问右子树
		}
	}
}

int main() {
	FILE* fin = fopen("input.txt", "r");
	struct TreeNode* root = NULL;
	createTree(&root, fin); // 从文件中读取数据创建二叉树
	printf("先根递归遍历: ");
	preOrderRecursive(root);
	printf("\n");
	printf("中根递归遍历: ");
	inOrderRecursive(root);
	printf("\n");
	printf("后根递归遍历: ");
	postOrderRecursive(root);
	printf("\n");
	printf("先根非递归遍历: ");
	preOrderNonRecursive(root);
	printf("\n");
	printf("中根非递归遍历: ");
	inOrderNonRecursive(root);
	printf("\n");
	printf("后根非递归遍历: ");
	postOrderNonRecursive(root);
	printf("\n");
	return 0;
}

</script>
<script>/*
实验3 Huffman编码
//从文件读取n个字符的出现概率，建立哈夫曼树，建立哈夫曼编码
#include <stdio.h>
#include <stdlib.h>

// 定义哈夫曼树节点
typedef struct Node {
	char data;
	int freq;
	struct Node* left;
	struct Node* right;
} Node;

// 函数声明
Node* buildHuffmanTree(Node** nodes, int n);
void generateHuffmanCodes(Node* root, char* code, int depth);

int main() {
	// 打开文件
	FILE* file = fopen("input.txt", "r");
	if (file == NULL) {
		perror("无法打开文件");
		exit(EXIT_FAILURE);
	}

	// 读取文件内容并计算字符频率
	int n = 256; // ASCII 字符数
	int freq[n];
	for (int i = 0; i < n; i++) {
		freq[i] = 0;
	}

	char ch;
	while ((ch = fgetc(file)) != EOF) {
		freq[ch]++;
	}

	// 关闭文件
	fclose(file);

	// 构建哈夫曼树节点数组
	Node* nodes[n];
	for (int i = 0; i < n; i++) {
		if (freq[i] > 0) {
			nodes[i] = (Node*)malloc(sizeof(Node));
			nodes[i]->data = (char)i;
			nodes[i]->freq = freq[i];
			nodes[i]->left = NULL;
			nodes[i]->right = NULL;
		} else {
			nodes[i] = NULL;
		}
	}

	// 构建哈夫曼树
	Node* root = buildHuffmanTree(nodes, n);

	// 生成哈夫曼编码
	char code[n];
	generateHuffmanCodes(root, code, 0);

	// 打印字符及其哈夫曼编码
	for (int i = 0; i < n; i++) {
		if (freq[i] > 0) {
			printf("字符 '%c' 的哈夫曼编码: %s\n", (char)i, code[i]);
		}
	}

	// 释放内存
	// TODO: 实现释放哈夫曼树节点内存的代码

	return 0;
}

// 构建哈夫曼树
Node* buildHuffmanTree(Node** nodes, int n) {
	// TODO: 实现构建哈夫曼树的代码
}

// 生成哈夫曼编码
void generateHuffmanCodes(Node* root, char* code, int depth) {
	// TODO: 实现生成哈夫曼编码的递归代码
}

</script>
<script>/*
实验4 图的创建与遍历
//从文件创建一个图，分别用邻接矩阵和邻接表存储。分别用深度和广度优先策略遍历。
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTEX 100

// 图的结点定义
typedef struct Node {
	int vertex;
	struct Node *next;
} Node;

// 邻接表定义
typedef struct {
	Node *head;
} AdjList[MAX_VERTEX];

// 图的定义
typedef struct {
	int numVertices;
	int numEdges;
	int isDirected;
	int matrix[MAX_VERTEX][MAX_VERTEX];
	AdjList adjList;
} Graph;

// 初始化图
void initGraph(Graph *graph, int numVertices, int isDirected) {
	int i, j;
	graph->numVertices = numVertices;
	graph->numEdges = 0;
	graph->isDirected = isDirected;

	// 初始化邻接矩阵
	for (i = 0; i < numVertices; ++i) {
		for (j = 0; j < numVertices; ++j) {
			graph->matrix[i][j] = 0;
		}
	}

	// 初始化邻接表
	for (i = 0; i < numVertices; ++i) {
		graph->adjList[i].head = NULL;
	}
}

// 添加边到邻接矩阵和邻接表
void addEdge(Graph *graph, int src, int dest) {
	// 添加到邻接矩阵
	graph->matrix[src][dest] = 1;

	// 添加到邻接表
	Node *newNode = (Node *)malloc(sizeof(Node));
	newNode->vertex = dest;
	newNode->next = graph->adjList[src].head;
	graph->adjList[src].head = newNode;
}

// 从文件读取图的信息并创建图
void createGraphFromFile(Graph *graph, const char *filename) {
	FILE *file = fopen(filename, "r");
	if (file == NULL) {
		printf("无法打开文件\n");
		exit(EXIT_FAILURE);
	}

	int numVertices, numEdges, isDirected;
	fscanf(file, "%d %d %d", &numVertices, &numEdges, &isDirected);

	initGraph(graph, numVertices, isDirected);

	int i, src, dest;
	for (i = 0; i < numEdges; ++i) {
		fscanf(file, "%d %d", &src, &dest);
		addEdge(graph, src, dest);
		if (!isDirected) {
			addEdge(graph, dest, src); // 无向图需添加反向边
		}
	}

	fclose(file);
}

// 邻接矩阵的深度优先遍历
void DFSMatrix(Graph *graph, int vertex, int *visited) {
	printf("%d ", vertex);
	visited[vertex] = 1;

	int i;
	for (i = 0; i < graph->numVertices; ++i) {
		if (graph->matrix[vertex][i] && !visited[i]) {
			DFSMatrix(graph, i, visited);
		}
	}
}

// 邻接表的深度优先遍历
void DFSList(Graph *graph, int vertex, int *visited) {
	printf("%d ", vertex);
	visited[vertex] = 1;

	Node *temp = graph->adjList[vertex].head;
	while (temp != NULL) {
		if (!visited[temp->vertex]) {
			DFSList(graph, temp->vertex, visited);
		}
		temp = temp->next;
	}
}

// 邻接矩阵的广度优先遍历
void BFSMatrix(Graph *graph, int start, int *visited) {
	int queue[MAX_VERTEX];
	int front = 0, rear = 0;

	printf("%d ", start);
	visited[start] = 1;
	queue[rear++] = start;

	while (front < rear) {
		int current = queue[front++];
		int i;
		for (i = 0; i < graph->numVertices; ++i) {
			if (graph->matrix[current][i] && !visited[i]) {
				printf("%d ", i);
				visited[i] = 1;
				queue[rear++] = i;
			}
		}
	}
}

// 邻接表的广度优先遍历
void BFSList(Graph *graph, int start, int *visited) {
	int queue[MAX_VERTEX];
	int front = 0, rear = 0;

	printf("%d ", start);
	visited[start] = 1;
	queue[rear++] = start;

	while (front < rear) {
		int current = queue[front++];
		Node *temp = graph->adjList[current].head;
		while (temp != NULL) {
			if (!visited[temp->vertex]) {
				printf("%d ", temp->vertex);
				visited[temp->vertex] = 1;
				queue[rear++] = temp->vertex;
			}
			temp = temp->next;
		}
	}
}

// 主函数
int main() {
	Graph graph;
	createGraphFromFile(&graph, "graph.txt");

	// 中文提示：深度优先遍历（邻接矩阵）
	int visited[MAX_VERTEX] = {0};
	printf("深度优先遍历（邻接矩阵）: ");
	DFSMatrix(&graph, 0, visited);
	printf("\n");

	// 中文提示：深度优先遍历（邻接表）
	for (int i = 0; i < MAX_VERTEX; ++i) {
		visited[i] = 0;
	}
	printf("深度优先遍历（邻接表）: ");
	DFSList(&graph, 0, visited);
	printf("\n");

	// 中文提示：广度优先遍历（邻接矩阵）
	for (int i = 0; i < MAX_VERTEX; ++i) {
		visited[i] = 0;
	}
	printf("广度优先遍历（邻接矩阵）: ");
	BFSMatrix(&graph, 0, visited);
	printf("\n");

	// 中文提示：广度优先遍历（邻接表）
	for (int i = 0; i < MAX_VERTEX; ++i) {
		visited[i] = 0;
	}
	printf("广度优先遍历（邻接表）: ");
	BFSList(&graph, 0, visited);
	printf("\n");

	return 0;
}



</script>
<script>/*
实验5 图的应用
//从文件创建一个带权图，分别求出最小生成树和最短路径
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// 定义图的最大顶点数
#define MAX_VERTICES 100

// 定义无穷大值
#define INFINITY INT_MAX

// 图的邻接矩阵表示
int graph[MAX_VERTICES][MAX_VERTICES];

// 顶点个数和边的个数
int numVertices, numEdges;

// 用于Prim算法的辅助数组
int parent[MAX_VERTICES];
int key[MAX_VERTICES];
int mstSet[MAX_VERTICES];

// 读取图的信息并初始化
void readGraphFromFile(FILE *file) {
	// 从文件中读取顶点个数和边的个数
	fscanf(file, "%d %d", &numVertices, &numEdges);

	// 初始化图的邻接矩阵
	for (int i = 0; i < MAX_VERTICES; i++) {
		for (int j = 0; j < MAX_VERTICES; j++) {
			graph[i][j] = 0;
		}
	}

	// 从文件中读取边的信息并更新图的邻接矩阵
	for (int i = 0; i < numEdges; i++) {
		int src, dest, weight;
		fscanf(file, "%d %d %d", &src, &dest, &weight);
		graph[src][dest] = weight;
		graph[dest][src] = weight;
	}
}

// 使用Prim算法求最小生成树
void primMST() {
	for (int i = 0; i < numVertices; i++) {
		key[i] = INFINITY;
		mstSet[i] = 0;
	}

	key[0] = 0;
	parent[0] = -1;

	for (int count = 0; count < numVertices - 1; count++) {
		int u = -1;
		int minKey = INFINITY;

		// 选择未加入最小生成树的顶点中具有最小键值的顶点
		for (int v = 0; v < numVertices; v++) {
			if (mstSet[v] == 0 && key[v] < minKey) {
				minKey = key[v];
				u = v;
			}
		}

		mstSet[u] = 1;

		// 更新与选定顶点相邻的顶点的键值
		for (int v = 0; v < numVertices; v++) {
			if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v]) {
				parent[v] = u;
				key[v] = graph[u][v];
			}
		}
	}
}

// 打印最小生成树
void printMST() {
	printf("最小生成树的边:\n");
	for (int i = 1; i < numVertices; i++) {
		printf("%d - %d 权重: %d\n", parent[i], i, graph[i][parent[i]]);
	}
}

// 使用Dijkstra算法求最短路径
void dijkstra(int src) {
	int dist[MAX_VERTICES];
	int visited[MAX_VERTICES];

	for (int i = 0; i < numVertices; i++) {
		dist[i] = INFINITY;
		visited[i] = 0;
	}

	dist[src] = 0;

	for (int count = 0; count < numVertices - 1; count++) {
		int u = -1;
		int minDist = INFINITY;

		// 选择未访问的顶点中距离最小的顶点
		for (int v = 0; v < numVertices; v++) {
			if (visited[v] == 0 && dist[v] < minDist) {
				minDist = dist[v];
				u = v;
			}
		}

		visited[u] = 1;

		// 更新与选定顶点相邻的顶点的距离
		for (int v = 0; v < numVertices; v++) {
			if (!visited[v] && graph[u][v] && dist[u] != INFINITY &&
			    dist[u] + graph[u][v] < dist[v]) {
				dist[v] = dist[u] + graph[u][v];
			}
		}
	}

	// 打印最短路径
	printf("\n从顶点 %d 到其他顶点的最短路径:\n", src);
	for (int i = 0; i < numVertices; i++) {
		printf("到顶点 %d 的最短路径距离: %d\n", i, dist[i]);
	}
}

int main() {
	FILE *file = fopen("graph.txt", "r");
	if (file == NULL) {
		printf("无法打开文件。\n");
		return 1;
	}

	readGraphFromFile(file);
	fclose(file);

	// 使用Prim算法求最小生成树
	primMST();
	printMST();

	// 使用Dijkstra算法求最短路径（假设起点为0）
	dijkstra(0);

	return 0;
}



</script>
<script>/*
实验6 二叉排序树的建立与查找
//从文件读入数据建立一棵二叉排序树，给定关键字进行查找
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
struct TreeNode {
	int data;
	struct TreeNode* left;
	struct TreeNode* right;
};

// 函数声明
struct TreeNode* insertNode(struct TreeNode* root, int key);
struct TreeNode* searchNode(struct TreeNode* root, int key);

// 从文件读取数据并构建二叉搜索树
struct TreeNode* buildBSTFromFile(const char* filename) {
	FILE* file = fopen(filename, "r");
	if (!file) {
		printf("无法打开文件 %s\n", filename);
		return NULL;
	}

	struct TreeNode* root = NULL;
	int value;

	// 从文件中读取数据并插入到二叉搜索树中
	while (fscanf(file, "%d", &value) == 1) {
		root = insertNode(root, value);
	}

	fclose(file);
	return root;
}

// 插入节点
struct TreeNode* insertNode(struct TreeNode* root, int key) {
	if (root == NULL) {
		// 创建新节点
		struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
		newNode->data = key;
		newNode->left = newNode->right = NULL;
		return newNode;
	}

	// 递归地插入节点
	if (key < root->data) {
		root->left = insertNode(root->left, key);
	} else if (key > root->data) {
		root->right = insertNode(root->right, key);
	}

	return root;
}

// 查找节点
struct TreeNode* searchNode(struct TreeNode* root, int key) {
	if (root == NULL || root->data == key) {
		return root;
	}

	// 在左子树或右子树中递归查找
	if (key < root->data) {
		return searchNode(root->left, key);
	} else {
		return searchNode(root->right, key);
	}
}

// 主函数
int main() {
	const char* filename = "data.txt";
	struct TreeNode* root = buildBSTFromFile(filename);

	if (root == NULL) {
		printf("构建二叉搜索树失败\n");
		return 1;
	}

	// 从文件读取关键字进行查找
	int searchKey;
	printf("请输入要查找的关键字: ");
	scanf("%d", &searchKey);

	struct TreeNode* result = searchNode(root, searchKey);

	if (result) {
		printf("找到关键字 %d\n", searchKey);
	} else {
		printf("未找到关键字 %d\n", searchKey);
	}

	return 0;
}

    
    
</script>
<script>/*
实验7 O（n乘n) 的排序算法
//从文件读入随机生成的n个数（n>10000)。用Bubble,Select等O(n*n)的复杂度算法进行排序
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 从文件中读取随机数
void readRandomNumbersFromFile(const char *filename, int *arr, int n) {
	FILE *file = fopen(filename, "r");
	if (file == NULL) {
		perror("无法打开文件");
		exit(EXIT_FAILURE);
	}

	for (int i = 0; i < n; ++i) {
		if (fscanf(file, "%d", &arr[i]) != 1) {
			fprintf(stderr, "从文件读取数出错");
			exit(EXIT_FAILURE);
		}
	}

	fclose(file);
}

// 冒泡排序
void bubbleSort(int *arr, int n) {
	for (int i = 0; i < n - 1; ++i) {
		for (int j = 0; j < n - i - 1; ++j) {
			if (arr[j] > arr[j + 1]) {
				// 交换arr[j]和arr[j+1]
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

// 选择排序
void selectionSort(int *arr, int n) {
	for (int i = 0; i < n - 1; ++i) {
		int minIndex = i;
		for (int j = i + 1; j < n; ++j) {
			if (arr[j] < arr[minIndex]) {
				minIndex = j;
			}
		}
		// 交换arr[i]和arr[minIndex]
		int temp = arr[i];
		arr[i] = arr[minIndex];
		arr[minIndex] = temp;
	}
}

int main() {
	const char *filename = "random_numbers.txt"; // 文件名
	int n = 10000; // 假设 n > 10000
	int *numbers = (int *)malloc(n * sizeof(int));

	// 从文件中读取随机数
	readRandomNumbersFromFile(filename, numbers, n);

	// 冒泡排序
	// bubbleSort(numbers, n);

	// 选择排序
	selectionSort(numbers, n);

	// 输出排序后的结果
	for (int i = 0; i < n; ++i) {
		printf("%d ", numbers[i]);
	}

	// 释放动态分配的内存
	free(numbers);

	return 0;
}

    
</script>
<script>/*
实验8 O(nlogn)的时间复杂度排序算法
//从文件读入n个数，用Quick，Merge Heap等O(nlogn)的算法进行排序
#include <stdio.h>
#include <stdlib.h>

// 快速排序算法
void quickSort(int arr[], int low, int high) {
	if (low < high) {
		int pivot = arr[high];
		int i = low - 1;

		for (int j = low; j < high; j++) {
			if (arr[j] <= pivot) {
				i++;
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}

		int temp = arr[i + 1];
		arr[i + 1] = arr[high];
		arr[high] = temp;

		int partitionIndex = i + 1;

		quickSort(arr, low, partitionIndex - 1);
		quickSort(arr, partitionIndex + 1, high);
	}
}

int main() {
	FILE *file;
	int n;

	// 打开文件
	file = fopen("input.txt", "r");
	if (file == NULL) {
		printf("无法打开文件\n");
		return 1;
	}

	// 读取数字个数
	fscanf(file, "%d", &n);

	// 读取数字数组
	int *arr = (int *)malloc(n * sizeof(int));
	for (int i = 0; i < n; i++) {
		fscanf(file, "%d", &arr[i]);
	}

	// 关闭文件
	fclose(file);

	// 使用快速排序算法排序
	quickSort(arr, 0, n - 1);

	// 输出排序后的结果
	printf("排序后的数组：\n");
	for (int i = 0; i < n; i++) {
		printf("%d ", arr[i]);
	}

	// 释放内存
	free(arr);

	return 0;
}

    
    
    
    */


</script>
<script>/*

    蓝奏 https://wwus.lanzouj.com/ijHBm1h3ygmj
    123 https://www.123pan.com/s/XIh5Vv-bmPJH.html
    GitHub https://github.com/zzzgydi/clash-verge/releases
    
    https://sub.sockboom.pro/sub?target=clash&new_name=true&url=https%3A%2F%2Fsockboom.me%2Flink%2Fskny81vAF6csaeVJ%3Fmu%3D1&filename=Sockboom&udp=true&config=https%3A%2F%2Fconfig.sockboom.me%2Fsubconfig.ini

*/
</script>
</body>
</html>